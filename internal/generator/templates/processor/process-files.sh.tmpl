#!/bin/bash
# File Processor - Main Processing Loop
# Generated by dockstart - https://github.com/jpequegn/dockstart
#
# This script watches for new files and processes them through the pipeline:
# pending/ -> processing/ -> processed/ (or failed/)

set -eo pipefail

# Configuration from environment variables
PENDING_DIR="${PENDING_PATH:-/files/pending}"
PROCESSING_DIR="${PROCESSING_PATH:-/files/processing}"
PROCESSED_DIR="${PROCESSED_PATH:-/files/processed}"
FAILED_DIR="${FAILED_PATH:-/files/failed}"
POLL_INTERVAL="${POLL_INTERVAL:-5}"
MAX_FILE_SIZE="${MAX_FILE_SIZE:-52428800}"  # 50MB default
RETRY_COUNT="${RETRY_COUNT:-3}"
RETRY_DELAY="${RETRY_DELAY:-10}"
NOTIFY_METHOD="${NOTIFY_METHOD:-file}"  # file, webhook, or redis

# Ensure directories exist
mkdir -p "$PENDING_DIR" "$PROCESSING_DIR" "$PROCESSED_DIR" "$FAILED_DIR"

# Log with timestamp
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

# Get file type using file command
get_file_type() {
    local file="$1"
    local mime_type
    mime_type=$(file --mime-type -b "$file" 2>/dev/null || echo "application/octet-stream")
    echo "$mime_type"
}

# Check if file size is within limits
check_file_size() {
    local file="$1"
    local size
    size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")

    if [ "$size" -gt "$MAX_FILE_SIZE" ]; then
        log "WARNING: File $file exceeds max size ($size > $MAX_FILE_SIZE bytes)"
        return 1
    fi
    return 0
}

# Process a single file
process_file() {
    local file="$1"
    local filename
    filename=$(basename "$file")
    local mime_type
    mime_type=$(get_file_type "$file")
    local result=0

    log "Processing: $filename (type: $mime_type)"

    # Move to processing directory
    mv "$file" "$PROCESSING_DIR/$filename"

    # Process based on mime type
    case "$mime_type" in
{{- if .ProcessImages}}
        image/jpeg|image/png|image/gif|image/webp)
            if [ -x /usr/local/bin/process-image.sh ]; then
                /usr/local/bin/process-image.sh "$PROCESSING_DIR/$filename" || result=$?
            else
                # Fallback: just move the file
                mv "$PROCESSING_DIR/$filename" "$PROCESSED_DIR/$filename"
            fi
            ;;
{{- end}}
{{- if .ProcessDocuments}}
        application/pdf)
            if [ -x /usr/local/bin/process-document.sh ]; then
                /usr/local/bin/process-document.sh "$PROCESSING_DIR/$filename" || result=$?
            else
                mv "$PROCESSING_DIR/$filename" "$PROCESSED_DIR/$filename"
            fi
            ;;
{{- end}}
{{- if .ProcessVideo}}
        video/mp4|video/quicktime|video/x-msvideo|video/webm)
            if [ -x /usr/local/bin/process-video.sh ]; then
                /usr/local/bin/process-video.sh "$PROCESSING_DIR/$filename" || result=$?
            else
                mv "$PROCESSING_DIR/$filename" "$PROCESSED_DIR/$filename"
            fi
            ;;
{{- end}}
        *)
            # Unknown file type - just move to processed
            log "Unknown file type, moving without processing: $filename"
            mv "$PROCESSING_DIR/$filename" "$PROCESSED_DIR/$filename"
            ;;
    esac

    # Handle result
    if [ $result -eq 0 ]; then
        # Clean up processing file if still exists (processor should have moved it)
        if [ -f "$PROCESSING_DIR/$filename" ]; then
            mv "$PROCESSING_DIR/$filename" "$PROCESSED_DIR/$filename"
        fi
        log "Completed: $filename"
        send_notification "$filename" "success"
    else
        # Move to failed directory
        if [ -f "$PROCESSING_DIR/$filename" ]; then
            mv "$PROCESSING_DIR/$filename" "$FAILED_DIR/$filename"
        fi
        echo "Processing failed with exit code $result" > "$FAILED_DIR/${filename}.error"
        log "Failed: $filename (exit code: $result)"
        send_notification "$filename" "failed"
    fi

    return $result
}

# Process file with retry logic
process_with_retry() {
    local file="$1"
    local filename
    filename=$(basename "$file")
    local attempt=1

    while [ $attempt -le "$RETRY_COUNT" ]; do
        if process_file "$file"; then
            return 0
        fi

        if [ $attempt -lt "$RETRY_COUNT" ]; then
            log "Retry $attempt/$RETRY_COUNT for $filename in ${RETRY_DELAY}s..."

            # Move back from failed to pending for retry
            if [ -f "$FAILED_DIR/$filename" ]; then
                mv "$FAILED_DIR/$filename" "$PENDING_DIR/$filename"
                rm -f "$FAILED_DIR/${filename}.error"
            fi

            sleep "$RETRY_DELAY"
        fi

        attempt=$((attempt + 1))
    done

    log "Failed after $RETRY_COUNT attempts: $filename"
    return 1
}

# Send notification when file is processed
send_notification() {
    local filename="$1"
    local status="$2"
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    case "$NOTIFY_METHOD" in
        file)
            # Create .done file with metadata
            cat > "$PROCESSED_DIR/${filename}.done" <<EOF
{
    "file": "$filename",
    "status": "$status",
    "timestamp": "$timestamp"
}
EOF
            ;;
        webhook)
            if [ -n "$WEBHOOK_URL" ]; then
                curl -s -X POST "$WEBHOOK_URL" \
                    -H "Content-Type: application/json" \
                    -d "{\"event\":\"file.processed\",\"file\":\"$filename\",\"status\":\"$status\",\"timestamp\":\"$timestamp\"}" \
                    || log "WARNING: Failed to send webhook notification"
            fi
            ;;
        redis)
            if [ -n "$REDIS_URL" ]; then
                redis-cli -u "$REDIS_URL" PUBLISH file:processed \
                    "{\"file\":\"$filename\",\"status\":\"$status\",\"timestamp\":\"$timestamp\"}" \
                    || log "WARNING: Failed to send Redis notification"
            fi
            ;;
    esac
}

# Main processing loop
main() {
    log "File processor started"
    log "Configuration:"
    log "  PENDING_DIR: $PENDING_DIR"
    log "  PROCESSED_DIR: $PROCESSED_DIR"
    log "  POLL_INTERVAL: ${POLL_INTERVAL}s"
    log "  MAX_FILE_SIZE: $MAX_FILE_SIZE bytes"
    log "  RETRY_COUNT: $RETRY_COUNT"
    log "  NOTIFY_METHOD: $NOTIFY_METHOD"
    log ""

{{- if .UseInotify}}
    # Use inotify for efficient file watching (Linux)
    if command -v inotifywait >/dev/null 2>&1; then
        log "Using inotify for file watching"
        inotifywait -m -e close_write --format '%w%f' "$PENDING_DIR" 2>/dev/null | while read -r file; do
            if [ -f "$file" ]; then
                # Wait a moment for file to be completely written
                sleep 1
                check_file_size "$file" && process_with_retry "$file" || true
            fi
        done
    else
        log "inotifywait not available, falling back to polling"
        polling_loop
    fi
{{- else}}
    # Use polling for cross-platform compatibility
    polling_loop
{{- end}}
}

# Polling-based file watching
polling_loop() {
    log "Using polling (interval: ${POLL_INTERVAL}s)"

    while true; do
        # Find files that have been completely written (older than 1 second)
        find "$PENDING_DIR" -type f -mmin +0.016 2>/dev/null | while read -r file; do
            if [ -f "$file" ]; then
                check_file_size "$file" && process_with_retry "$file" || true
            fi
        done

        sleep "$POLL_INTERVAL"
    done
}

# Run main loop
main "$@"
